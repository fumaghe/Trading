name: Young Whale Recap (every 6 hours)

on:
  schedule:
    - cron: "0 */6 * * *"  # ogni 6 ore (UTC)
  workflow_dispatch: {}

permissions:
  contents: read

jobs:
  recap-6h:
    runs-on: ubuntu-latest
    env:
      PYTHONIOENCODING: "utf-8"
      TG_BOT_TOKEN: ${{ secrets.TG_BOT_TOKEN }}
      TG_CHAT_ID:   ${{ secrets.TG_CHAT_ID }}
      RECAP_HOURS: "6"
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Build 6h recap message
        id: recap
        shell: bash
        run: |
          mkdir -p out/recap
          python - << 'PY'
          import os, json, glob, html
          from datetime import datetime, timezone, timedelta

          HOURS = int(os.getenv("RECAP_HOURS", "6"))
          now = datetime.now(timezone.utc)
          since = now - timedelta(hours=HOURS)
          now_ts = now.timestamp()
          since_ts = since.timestamp()

          files = sorted(glob.glob("history/**/*.json", recursive=True))
          if not files:
              msg = f"üß≠ <b>Recap ultime {HOURS}h</b>\nNessun dato disponibile."
              open("out/recap/recap.html","w",encoding="utf-8").write(msg)
              raise SystemExit(0)

          def dex_link(pair, token):
              if pair: return f"https://dexscreener.com/bsc/{pair}"
              return f"https://dexscreener.com/bsc/{token}"

          def zerion(addr):
              return f"https://debank.com/profile/{addr}"

          def short_addr(a: str) -> str:
              a = (a or "").strip()
              if a.startswith("0x") and len(a) > 12:
                  return a[:6] + "..." + a[-4:]
              if len(a) > 12:
                  return a[:6] + "..." + a[-4:]
              return a

          def fmt_money(v):
              try:
                  return f"${float(v):,.0f}".replace(",", " ")
              except Exception:
                  return str(v)

          def parse_ts(j):
              ts = j.get("ts")
              if ts:
                  try:
                      return datetime.fromisoformat(ts.replace("Z","+00:00")).timestamp()
                  except Exception:
                      pass
              return None

          per_token = {}
          overall_top = {}
          addr_name = {}

          runs_total = 0
          iterations_total = 0
          wallets_seen_total = 0
          buys_usd_total = 0.0

          for f in files:
              try:
                  j = json.load(open(f,"r",encoding="utf-8"))
              except Exception:
                  continue
              ts_run = parse_ts(j)
              if ts_run is None or ts_run < since_ts or ts_run > now_ts:
                  continue

              sym = j.get("symbol") or "TOKEN"
              token_addr = j.get("token") or ""
              pair = j.get("main_pair_hint") or ""
              price = j.get("price_usd")

              stats = j.get("stats") or {}
              agg = j.get("agg") or {}

              d = per_token.setdefault(sym, {
                "token": token_addr,
                "pair": pair,
                "runs": 0,
                "iterations": 0,
                "wallets_seen": 0,
                "buys_usd": 0.0,
                "prices": [],
                "top_map": {}
              })

              d["runs"] += 1
              d["iterations"] += int(stats.get("total_swaps_scanned") or 0)
              d["wallets_seen"] += int(agg.get("buyers_unique_all") or stats.get("wallet_unici_ge_min_usd") or 0)
              try:
                  d["buys_usd"] += float(agg.get("buyers_total_usd_window_all") or 0.0)
              except Exception:
                  pass
              if price is not None:
                  try:
                      d["prices"].append((ts_run, float(price)))
                  except Exception:
                      pass

              for w in (agg.get("top_spenders_all") or []):
                  addr = (w.get("address") or "").strip()
                  amt = float(w.get("sum_buys_usd_window") or 0.0)
                  name = (w.get("user_name") or "").strip()  # nome presente SOLO se wallet validato
                  if not addr:
                      continue
                  d["top_map"][addr] = d["top_map"].get(addr, 0.0) + amt
                  overall_top[addr] = overall_top.get(addr, 0.0) + amt
                  if name:
                      addr_name[addr] = name  # non sovrascrivo se vuoto

          # Aggregati globali
          for sym, d in per_token.items():
              runs_total += d["runs"]
              iterations_total += d["iterations"]
              wallets_seen_total += d["wallets_seen"]
              buys_usd_total += d["buys_usd"]

          header = f'üß≠ <b>Recap ultime {HOURS}h</b> (UTC)\n<code>{since.strftime("%Y-%m-%d %H:%M")} ‚Üí {now.strftime("%Y-%m-%d %H:%M")}</code>\n'
          ov1 = f'üì¶ Run: <b>{runs_total}</b>  ‚Ä¢  üîÅ Iterazioni: <b>{iterations_total}</b>\n'
          ov2 = f'üëõ Wallet analizzati (stima): <b>{wallets_seen_total}</b>\n'
          ov3 = f'üíµ Volume acquisti (>= soglia): <b>{fmt_money(buys_usd_total)}</b>\n'
          parts = [header, ov1, ov2, ov3, ""]

          # Top overall (max 5) ‚Äî testo link = nome se presente, altrimenti address troncato
          top_overall = sorted(overall_top.items(), key=lambda kv: kv[1], reverse=True)[:5]
          if top_overall:
              parts.append("üëë <b>Top buyer globali</b>")
              lines = []
              for i,(addr,amt) in enumerate(top_overall, start=1):
                  display = addr_name.get(addr, short_addr(addr))
                  link = zerion(addr)
                  lines.append(f'{i}) <a href="{link}"><b>{html.escape(display)}</b></a> ‚Äî {fmt_money(amt)}')
              parts.append("\n".join(lines))
              parts.append("")

          # Sezioni per token
          for sym, d in sorted(per_token.items()):
              ptxt = ""
              if d["prices"]:
                  d["prices"].sort(key=lambda x: x[0])
                  p0 = d["prices"][0][1]
                  p1 = d["prices"][-1][1]
                  if p0 and p1 is not None:
                      delta = p1 - p0
                      pct = (delta / p0 * 100.0) if p0 != 0 else 0.0
                      sign = "‚ÜóÔ∏è" if pct > 0 else ("‚ÜòÔ∏è" if pct < 0 else "‚Üí")
                      ptxt = f"üí± Prezzo: <b>{p1:.6f}</b> ({sign} {pct:+.2f}%)"

              link = dex_link(d["pair"], d["token"])
              head = f'ü™ô <a href="{link}"><b>{html.escape(sym)}</b></a>'
              meta = f' ‚Äî run: <b>{d["runs"]}</b> ‚Ä¢ üîÅ <b>{d["iterations"]}</b> ‚Ä¢ üëõ <b>{d["wallets_seen"]}</b> ‚Ä¢ üíµ <b>{fmt_money(d["buys_usd"])}</b>'
              parts.append(head + meta)
              if ptxt:
                  parts.append(ptxt)

              # top buyers per token (max 3) ‚Äî testo link troncato se manca nome
              top_tok = sorted(d["top_map"].items(), key=lambda kv: kv[1], reverse=True)[:3]
              if top_tok:
                  lines = []
                  for i,(addr,amt) in enumerate(top_tok, start=1):
                      display = addr_name.get(addr, short_addr(addr))
                      linkw = zerion(addr)
                      lines.append(f'{i}) <a href="{linkw}"><b>{html.escape(display)}</b></a> ‚Äî {fmt_money(amt)}')
                  parts.append("üëë Top buyer:\n" + "\n".join(lines))
              parts.append("")

          msg = "\n".join(parts).strip()
          open("out/recap/recap.html","w",encoding="utf-8").write(msg)
          PY

      - name: Send Telegram ‚Äî 6h Recap (auto-split by line)
        if: env.TG_BOT_TOKEN != '' && env.TG_CHAT_ID != ''
        shell: bash
        run: |
          FILE="out/recap/recap.html"
          if [ ! -f "$FILE" ]; then
            echo "Nessun recap generato."
            exit 0
          fi

          mkdir -p out/recap/parts

          # Split del messaggio in pi√π parti rispettando i newline
          python - << 'PY'
          import os

          MAX_LEN = 3500  # sicuro sotto il limite Telegram (4096)
          src = "out/recap/recap.html"
          dst_dir = "out/recap/parts"
          os.makedirs(dst_dir, exist_ok=True)

          with open(src, "r", encoding="utf-8") as f:
              text = f.read().strip()

          if not text:
              raise SystemExit(0)

          lines = text.split("\n")
          parts = []
          buf = ""

          for line in lines:
              candidate = (buf + "\n" + line) if buf else line
              if len(candidate) > MAX_LEN:
                  if buf:
                      parts.append(buf.rstrip())
                  buf = line
                  # Se una singola riga √® pi√π lunga di MAX_LEN, la mandiamo comunque intera
                  if len(buf) > MAX_LEN:
                      parts.append(buf)
                      buf = ""
              else:
                  buf = candidate

          if buf:
              parts.append(buf.rstrip())

          for idx, chunk in enumerate(parts, start=1):
              out_path = os.path.join(dst_dir, f"recap_part_{idx:02d}.html")
              with open(out_path, "w", encoding="utf-8") as f:
                  f.write(chunk)
          PY

          API="https://api.telegram.org/bot${TG_BOT_TOKEN}/sendMessage"
          shopt -s nullglob
          PARTS=(out/recap/parts/recap_part_*.html)

          if [ ${#PARTS[@]} -eq 0 ]; then
            echo "Nessun contenuto da inviare."
            exit 0
          fi

          for f in "${PARTS[@]}"; do
            TEXT="$(cat "$f")"
            curl -sS -X POST "$API" \
              --data-urlencode "chat_id=${TG_CHAT_ID}" \
              --data-urlencode "text=$TEXT" \
              -d "disable_web_page_preview=true" \
              -d "parse_mode=HTML" \
            || echo "Telegram send failed ($f)"
            sleep 0.6
          done

      - name: Upload recap artifact
        uses: actions/upload-artifact@v4
        with:
          name: young-whale-recap-6h
          path: out/recap/recap.html

          