name: Young Whale Finder — Recap (every 6h)

on:
  schedule:
    - cron: "0 */6 * * *"    # ogni 6 ore (UTC)
  workflow_dispatch: {}

permissions:
  contents: read

concurrency:
  group: young-whale-finder-recap
  cancel-in-progress: true

jobs:
  recap:
    runs-on: ubuntu-latest
    env:
      PYTHONIOENCODING: "utf-8"
      TG_BOT_TOKEN: ${{ secrets.TG_BOT_TOKEN }}
      TG_CHAT_ID:   ${{ secrets.TG_CHAT_ID }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Build 6h recap and send Telegram
        shell: bash
        run: |
          python - << 'PY'
          import os, json, glob
          from datetime import datetime, timezone, timedelta
          import urllib.parse, urllib.request

          TG_TOKEN = os.environ.get("TG_BOT_TOKEN","")
          TG_CHAT  = os.environ.get("TG_CHAT_ID","")

          now = datetime.utcnow().replace(tzinfo=timezone.utc)
          since = now - timedelta(hours=6)

          # Carica i summary prodotti dal workflow principale (uno per run)
          files = sorted(glob.glob("data/ywf_runs/run-*.json"))
          runs = []
          for f in files:
              try:
                  with open(f,"r",encoding="utf-8") as fh:
                      j = json.load(fh)
                  ts = j.get("timestamp_utc")
                  if not ts:
                      continue
                  ts_dt = datetime.fromisoformat(ts.replace("Z","+00:00"))
                  if ts_dt >= since and ts_dt <= now:
                      runs.append((ts_dt, j))
              except Exception as e:
                  print(f"[DEBUG] skip {f}: {e}")

          runs.sort(key=lambda x: x[0])

          # Aggregati base
          total_iterations = len(runs)
          total_wallets_seen = 0
          total_messages = 0

          # Mappa prezzi per simbolo (per variazione 6h)
          price_map = {}  # sym -> list of (ts_dt, price)
          for ts_dt, r in runs:
              totals = r.get("totals", {})
              total_wallets_seen += int(totals.get("wallets_seen", 0))
              total_messages += int(totals.get("messages_sent", 0))
              for t in r.get("tokens", []):
                  sym = t.get("symbol")
                  price = t.get("price_usd")
                  if sym is None or price in (None, "", "null"):
                      continue
                  try:
                      p = float(price)
                  except:
                      continue
                  price_map.setdefault(sym, []).append((ts_dt, p))

          # Helper formattazione
          def fmt_int(n):
              try:
                  return f"{int(n):,}".replace(",", " ")
              except:
                  return str(n)

          def fmt_price(p):
              try:
                  return f"${float(p):,.4f}".replace(",", " ")
              except:
                  return str(p)

          # Variazioni prezzo (primo->ultimo nella finestra)
          lines_prices = []
          for sym, arr in sorted(price_map.items()):
              arr.sort(key=lambda x: x[0])
              first = arr[0][1]
              last = arr[-1][1]
              try:
                  pct = ((last - first) / first) * 100 if first else None
              except:
                  pct = None
              if pct is not None:
                  lines_prices.append(f"- {sym}: {fmt_price(first)} → {fmt_price(last)} ({pct:+.2f}%)")
              else:
                  lines_prices.append(f"- {sym}: {fmt_price(first)} → {fmt_price(last)}")

          # Header con finestra temporale
          win_from = since.strftime("%Y-%m-%d %H:%M")
          win_to   = now.strftime("%Y-%m-%d %H:%M")
          hdr = "⏱️ Young Whale Finder — Recap ultime 6 ore"
          sub = f"Finestra: <b>{win_from}–{win_to} UTC</b>"

          # Se nessun run, mandiamo comunque un recap "vuoto"
          if total_iterations == 0:
              body = "\n".join([
                  hdr,
                  sub,
                  f"Iterazioni eseguite: <b>0</b>",
                  f"Wallet analizzati (≥ min): <b>0</b>",
                  f"Wallet segnalati (inviati): <b>0</b>",
              ])
          else:
              base = [
                  hdr,
                  sub,
                  f"Iterazioni eseguite: <b>{fmt_int(total_iterations)}</b>",
                  f"Wallet analizzati (≥ min): <b>{fmt_int(total_wallets_seen)}</b>",
                  f"Wallet segnalati (inviati): <b>{fmt_int(total_messages)}</b>",
              ]
              if lines_prices:
                  base.extend(["", "<u>Prezzo token (Δ 6h)</u>:", *lines_prices])
              body = "\n".join(base)

          print("=== Recap ===")
          print(body)

          if TG_TOKEN and TG_CHAT:
              API=f"https://api.telegram.org/bot{TG_TOKEN}/sendMessage"
              data = {
                "chat_id": TG_CHAT,
                "text": body,
                "disable_web_page_preview": "true",
                "parse_mode": "HTML"
              }
              try:
                  req = urllib.request.Request(API, data=urllib.parse.urlencode(data).encode("utf-8"))
                  with urllib.request.urlopen(req, timeout=20) as resp:
                      print("Telegram ok", resp.status)
              except Exception as e:
                  print("Telegram send failed:", e)
          else:
              print("Telegram non configurato; recap non inviato.")
          PY
